enclave {
    from "sgx_tstdc.edl" import *;
    from "sgx_tcrypto.edl" import *;

    // note: i am trying to keep the interface as clean and minimal as 
    // possible here as we want the enclave to be easy to reason about.
    trusted {
        // hash: reads and hashes the binary inside enclave, then stores it
        public sgx_status_t ecall_hash(
            [in, string] const char* binary_path
        );
        
        // generate_credentials for launching the service
        public sgx_status_t ecall_generate_credentials(
            [out] uint8_t* secret_key,
            uint64_t secret_key_len,
            [out] uint8_t* public_key,
            uint64_t public_key_len
        );
        
        // get_attestation_report: get report with hash + public key for remote attestation
        public sgx_status_t ecall_get_attestation_report(
            [in] const sgx_target_info_t* target_info,
            [out] sgx_report_t* report,
            [out, size=hash_len] uint8_t* binary_hash,
            uint64_t hash_len,
            [out, size=pubkey_len] uint8_t* public_key,
            uint64_t pubkey_len
        );
    };

    untrusted {
        // read_file_chunk: read a chunk of the binary file from disk
        void ocall_read_file_chunk(
            [in, string] const char* path,
            [in] uint64_t offset,
            [out, size=chunk_size] uint8_t* buffer,
            uint64_t chunk_size,
            [out] uint64_t bytes_read[1]
        );
        
        // print: just your everyday stdout
        void ocall_print([in, string] const char* str);
    };
};
